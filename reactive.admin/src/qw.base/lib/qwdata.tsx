// A '.tsx' file enables JSX support in the TypeScript compiler, 
// for more information see the following page on the TypeScript wiki:
// https://github.com/Microsoft/TypeScript/wiki/JSX






export class DataSource {

    constructor(model: string) {
        this.model = model;
    }


    model: string;


    private _dm: breeze.EntityManager;
    get dm(): breeze.EntityManager {

        if (!this._dm) {
            this._dm = new breeze.EntityManager({
                dataService: new breeze.DataService({
                    serviceName: '{0}'.format(utils.srv_url),
                    //hasServerMetadata : false             
                    //useJsonp : true
                }),
                validationOptions: new breeze.ValidationOptions({
                    validateOnSave: false,
                    validateOnAttach: false,
                    validateOnQuery: true
                })
            });

        }
        return this._dm;
    }


    fetch_data(qry?: Backendless.DataQueryValueI): Q.Promise<any> {
        
        if (!this.dm.metadataStore.hasMetadataFor(this.model)) {

            return this.fetch_metadata().then(args => {

                return this.fetch_dataEx(qry);
            });
        }

        return this.fetch_dataEx(qry);
    }


    private fetch_dataEx(qry?: Backendless.DataQueryValueI): Q.Promise<any> {

        var d = Q.defer();

        Backendless.Persistence.of(this.model).find(new Backendless.Async( (list:any) => {
            
            _.each(list.data, obj => {
                this.dm.createEntity(this.model, obj, breeze.EntityState.Unchanged, breeze.MergeStrategy.OverwriteChanges);
            });

            var entities = this.dm.getEntities(this.model);

            d.resolve(entities);

        }, err => {

            d.reject(err);

        }));

        return d.promise;

    }


    fetch_metadata(): Q.Promise<any> {

        var d = Q.defer();

        Backendless.Persistence.describe(this.model, new Backendless.Async( (list:any[]) => {

            var props: any = {};

            _.each(list, s => {

                props[s.name] = {
                    isprimary: s.isPrimaryKey
                };

            });

            Store.create_entity_def({
                entityname: this.model,
                master_key: '',
                properties:props
            });

            this.dm.metadataStore.importMetadata(Store.Store.exportMetadata());

            d.resolve(true);
            
        }, err => {

            d.reject(err);

        }));

        return d.promise;
    }

}



export module Store {

    var _entities_cache: EntityTypeDefinition[] = []

    export interface PropertyDef {
        type?: breeze.DataTypeSymbol
        isprimary?: boolean,
    }


    export interface PropertyDefs {
        [name: string]: PropertyDef
    }


    export interface EntityDef {
        entityname: string,
        master_key?: string,
        properties: PropertyDefs,
        relations?: {
            [name: string]: EntityDef
        }
    }

    var DT = breeze.DataType;
    var defaultNameSpace = '';

    var Identity = breeze.AutoGeneratedKeyType.Identity;
    var Validator = breeze.Validator;
    var camelCaseConvention: breeze.NamingConvention = breeze.NamingConvention.none;

    // Breeze Labs: breeze.metadata.helper.js
    var helper = new breeze.config['MetadataHelper']();

    // Helper convenience methods
    var addDataService = helper.addDataService.bind(helper);
    var addTypeToStore = helper.addTypeToStore.bind(helper);
    var setDefaultNamespace = helper.setDefaultNamespace.bind(helper);

    var dataNameSpace = 'afrikNetMarket';

    export interface DataProperties {
        [name: string]: DataPropertyDefinition
    }

    export interface DataPropertyDefinition {
        dataType?: breeze.DataTypeSymbol;
        defaultValue?: any;
        isPartOfKey?: boolean;
        isUnmapped?: boolean;
        maxLength?: number;
    }


    export interface Extensions {
        [name: string]: DataPropertyExtension
    }


    export interface DataPropertyExtension {
        description: string
    }


    export interface EntityTypeDefinition {
        namespace?: string;
        shortName?: string;
        defaultResourceName: string,
        autoGeneratedKeyType?: breeze.AutoGeneratedKeyType,
        dataProperties: DataProperties;
        complexProperties?: breeze.DataProperty[];
        unmappedProperties?: breeze.DataProperty[];
        validators?: breeze.Validator[];
        //navigationProperties?: breeze.NavigationProperty[];
        navigationProperties?: any,
        custom?: Extensions
    }

    setDefaultNamespace(dataNameSpace);

    function __addEntityType(store: breeze.MetadataStore, type: EntityTypeDefinition) {

        var _type = _.extend(type, {
            namespace: dataNameSpace,
            shortName: type.defaultResourceName,
            autoGeneratedKeyType: breeze.AutoGeneratedKeyType.None,
        });

        addTypeToStore(store, _type);
    }


    function __createDataStore(storeName: string): breeze.MetadataStore {

        var store: breeze.MetadataStore = new breeze.MetadataStore({
            namingConvention: camelCaseConvention
        });
        addDataService(store, storeName);

        return store;
    }


    interface Schema {
        srvName: string,
        store: breeze.MetadataStore
    }


    var dbSchema: Schema[] = [];


    function __regsiterSchema(srvName: string, store: breeze.MetadataStore) {

        dbSchema.push({
            srvName: srvName,
            store: store
        });
    }

    export var Store: breeze.MetadataStore = new breeze.MetadataStore({ namingConvention: camelCaseConvention });


    addDataService(Store, 'DataStore');
    setDefaultNamespace('QuickWave');


    export function add_to_Store(type: EntityTypeDefinition) {

        _entities_cache.push(type);

        var _type = _.extend(type, {
            namespace: dataNameSpace,
            shortName: type.defaultResourceName,
            autoGeneratedKeyType: breeze.AutoGeneratedKeyType.None,
        });

        addTypeToStore(Store, _type);
    }


    export function create_entity_def(source_def: EntityDef, master_src_def?: EntityDef) {

        var target_ent: EntityTypeDefinition = {
            defaultResourceName: source_def.entityname,
            dataProperties: {},
            navigationProperties: {}
        }

        _.each(Object.keys(source_def.properties), k => {

            var prop_def = source_def.properties[k];

            target_ent.dataProperties[k] = {
                dataType: prop_def.type ? prop_def.type : DT.String,
                isPartOfKey: prop_def.isprimary ? prop_def.isprimary : false
            }
        });

        target_ent.dataProperties['created'] = { dataType: breeze.DataType.DateTime }
        target_ent.dataProperties['updated'] = { dataType: breeze.DataType.DateTime }

        var has_primary = _.find(Object.keys(target_ent.dataProperties), k => {
            return target_ent.dataProperties[k].isPartOfKey
        });

        //if (!has_primary) {
        //    target_ent.dataProperties['id'] = { dataType: DT.String, isPartOfKey: true }
        //}

        if (master_src_def) {

            target_ent.navigationProperties[master_src_def.entityname] = {
                type: master_src_def.entityname,
                assoc: 'association_{0}_{1}'.format(master_src_def.entityname, source_def.entityname),
                foreignKeyNames: [source_def.master_key]
            }
        }

        if (source_def.relations) {

            _.each(Object.keys(source_def.relations), rel => {

                target_ent.navigationProperties[rel] = {
                    entityTypeName: rel,
                    associationName: 'association_{0}_{1}'.format(target_ent.defaultResourceName, rel),
                    isScalar: false
                }

                add_to_Store(target_ent);

                var rel_ent = source_def.relations[rel];

                create_entity_def(rel_ent);

            });

        } else {

            add_to_Store(target_ent);
        }
    }


    export function register_entity_defs() {

        _.each(_entities_cache, ent => {
            add_to_Store(ent);
        });

    }

}

